---
title: "mlr3 - Runtime and Memory Benchmarks"
sidebar: false
toc: true
cache: false
lazy-cache: false
format:
  html:
    fig-width: 12
    fig-height: 9
---

{{< include ../_setup.qmd >}}

```{r}
#| include: false
library(data.table)
library(ggplot2)
library(gt)
library(DBI)

con = dbConnect(RSQLite::SQLite(), here::here("mlr-org/benchmarks/results_lrz.db"))
snapshot = setDT(dbReadTable(con, "rush_snapshots"))
snapshot[, rush := factor(rush)]

jobs_runtime = setDT(dbReadTable(con, "rush_runtime_jobs"))
jobs_runtime[, args := map(args, function(args) unserialize(args))]

results_runtime = set_names(pmap(jobs_runtime, function(function_name, args, ...) {
  arg_names = names(args)
  data_runtime = setDT(dbReadTable(con, sprintf("rush_runtime_%s", function_name)))[, c(arg_names, "renv_project", "median_runtime", "mad_runtime"), with = FALSE]
  data_runtime = data_runtime[snapshot, on = "renv_project", nomatch = 0]
  setorderv(data_runtime, c(arg_names, "rush"), order = c(rep(1, length(arg_names)), -1))
  data_runtime[, -c("renv_project")]
}), jobs_runtime$function_name)
```

# Scope

This report analyzes the runtime and memory usage of `rush` across the most recent package versions.
It focuses on the core methods `$push_running_tasks()`, `$push_results()` and `$fetch_finished_tasks()`.
This report helps users assess whether observed runtimes fall within expected ranges.
Substantial anomalies in runtime should be reported by opening a GitHub issue.
Benchmarks are executed on a high‑performance cluster optimized for multi‑core throughput rather than single‑core speed.
Consequently, single‑core runtimes may be faster on a modern local machine.

# Summary of Latest rush Version

We summarize the results for the latest `rush` version.
The overhead of `$push_running_tasks()` and `$push_results()` is below a half millisecond.
The runtime of `$fetch_finished_tasks()` depends on the number of tasks and the cache size.
When no tasks are cached, the runtime for 1 to 1000 tasks is around 1 ms
When one new task is fetched and the rest is cached, the runtime ranges between 12 and 37 ms depending of the cache size.

# Push Running Tasks {#push-running-tasks}

```{r}
#| include: false

# gt table for experiments that depend on the task size
table_task = function(data) {
  data = data[, -c("mad_runtime")]
  setcolorder(data, c("rush", "n_parameters", "n_tasks", "median_runtime"))
  setorderv(data, c("n_parameters", "n_tasks"), order = c(-1, 1))

  data[, list(rush, n_parameters, n_tasks, median_runtime)] %>%
    gt() %>%
    cols_label(
      rush = "rush",
      n_parameters = "Number of Parameters",
      n_tasks = "Number of Tasks",
      median_runtime = "Runtime"
    ) %>%
    cols_units(
      median_runtime = "ms"
    ) %>%
    fmt_number(columns = c("median_runtime"), n_sigfig = 2, sep_mark = "") %>%
    fmt_number(columns = c("n_tasks"), decimals = 0, sep_mark = ",") %>%
    tab_row_group(
      label = "1 Parameter",
      rows = n_parameters == 1
    ) %>%
    tab_row_group(
      label = "10 Parameters",
      rows = n_parameters == 10
    )
  }
```

The runtime of `$push_running_tasks()`.

```{r}
#| eval: false
xss = list(list(x1 = 1))
keys = rush$push_running_tasks(xss)
```

```{r}
#| echo: false
#| warning: false
#| column: body-outset
#| tbl-cap: |
#|   Runtime of `$push_running_tasks()` by rush version.
table_task(results_runtime$push_running_tasks)
```

# Push Results {#push-results}

The runtime of `$push_results()`.

```{r}
#| eval: false
yss = list(list(y = 1))
rush$push_results(keys, yss)
```

```{r}
#| echo: false
#| warning: false
#| column: body-outset
#| tbl-cap: |
#|   Runtime of `$push_results()` by rush version.
table_task(results_runtime$push_results)
```

# Fetch Finished Tasks {#fetch-finished-tasks}

The runtime of `$fetch_finished_tasks()`.

```{r}
#| eval: false
rush$fetch_finished_tasks()
```

```{r}
#| echo: false
#| warning: false
#| column: body-outset
#| tbl-cap: |
#|   Runtime of `$fetch_finished_tasks()` by number of tasks and rush version.
table_task(results_runtime$fetch_finished_tasks)
```

# Fetch Finished Tasks with Cache {#fetch-finished-tasks-with-cache}

The runtime of `$fetch_finished_tasks()` when one new task is fetched and the other tasks are cached.

```{r}
#| eval: false
rush$fetch_finished_tasks()
```

```{r}
#| echo: false
#| warning: false
#| column: body-outset
#| tbl-cap: |
#|   Runtime of `$fetch_finished_tasks()` with cache by cache size and rush version.
table_task(results_runtime$fetch_cached_tasks)
```

```{r}
#| echo: false
#| fig-cap: |
#|   "Runtime of fetching finished tasks with (red lines) and without (blue lines) caching."
#|   "The x-axis shows the number of tasks fetched from the database."
#|   "The fetching with caching gets one new task from the database and the rest from the cache."
#|   "The fetching without caching gets all tasks from the database."
#| label: fig-fetch-finished-tasks
library(data.table)
library(ggplot2)

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}


data = rbindlist(list(
  results_runtime$fetch_finished_tasks[n_parameters == 1, list(n_tasks = n_tasks, runtime = median_runtime, benchmark = "fetch_tasks")],
  results_runtime$fetch_cached_tasks[n_parameters == 1, list(n_tasks = n_tasks, runtime = median_runtime, benchmark = "fetch_cached_tasks")]
))

ggplot(data, aes(x = n_tasks, y = runtime, color = benchmark)) +
  scale_x_continuous(trans='log10') +
  #scale_y_continuous(trans='log10') +
  geom_line() +
  geom_point() +
  scale_color_manual(values = gg_color_hue(2), labels = c("with cache", "without cache")) +
  labs(x = "Number of Tasks", y = "Runtime (ms)", color = "Fetching") +
  theme_minimal()
```
