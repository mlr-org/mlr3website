{
  "hash": "3c08ee314c9a8d5e4c1f1cfdaff7fb06",
  "result": {
    "markdown": "---\ntitle: \"Visualization of spatial cross-validation partitioning\"\nauthors: [\"Patrick Schratz\"]\ndate: 2018-07-25\ncategories: [\"R\", \"r-bloggers\"]\ntags: [\"spatial\", \"resampling\", \"spatial-CV\", \"rstats\", \"performance estimation\"]\ndescription: \"Visualizing spatial cross-validation in mlr\"\n\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\nIn July `mlr` got a new feature that extended the support for spatial data: The ability to visualize spatial partitions in cross-validation (CV) [9d4f3](https://github.com/mlr-org/mlr/commit/9d4f391d182f2a50ba532e91b59184adeb88ceb1).\nWhen one uses the resampling descriptions \"SpCV\" or \"SpRepCV\" in `mlr`, the k-means clustering approach after Brenning (2005) is used to partition the dataset into equally sized, spatially disjoint subsets.\nSee also [this](https://www.r-spatial.org/r/2018/03/03/spatial-modeling-mlr.html) post on r-spatial.org and the [mlr vignette about spatial data](http://mlr.mlr-org.com/articles/handling_of_spatial_data.html) for more information.\n\n# Visualization of partitions\n\nWhen using random partitiong in a normal cross-validation, one is usually not interested in the random pattern of the datasets train/test split\nHowever, for spatial data this information is important since it can help identifying problematic folds (ones that did not converge or showed a bad performance) and also proves that the k-means clustering algorithm did a good job on partitioning the dataset.\n\nThe new function to visualize these partitions in `mlr` is called `createSpatialResamplingPlots()`.\nIt uses `ggplot2` and its new `geom_sf()` function to create spatial plots based on the resampling indices of a `resample()` object.\nIn this post we will use the examples of the function to demonstrate its use.\n\nFirst, we create a resampling description `rdesc` using spatial partitioning with five folds and repeat it 4 times.\nThis `rdesc` object is put into a `resample()` call together with our example task for spatial matters, `spatial.task`.\nFinally, we use the `classif.qda` learner to have a quick model fit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlr)\nrdesc = makeResampleDesc(\"SpRepCV\", folds = 5, reps = 4)\nresamp = resample(makeLearner(\"classif.qda\"), spatial.task, rdesc)\n```\n:::\n\n\nNow we can use `createSpatialResamplingPlots()` to automatically create one plot for each fold of the `resamp` object.\nUsually we do not want to plot all repetitions of the CV.\nWe can restrict the number of repetitions in the argument `repetitions`.\n\nBesides the required arguments `task` and `resample`, the user can specifiy the coordinate reference system that should be used for the plots.\nHere it is important to set the correct EPSG number in argument `crs` to receive accurate spatial plots.\nIn the background, `geom_sf()` (more specifically `coords_sf()`) will transform the CRS on the fly to EPSG: 4326.\nThis is done because lat/lon reference systems are better for plotting as UTM coordinates usually clutter the axis.\nHowever, if you insist on using UTM projection instead of WGS84 (EPSG: 4326) you can set the EPSG code of your choice in argument `datum`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots = createSpatialResamplingPlots(spatial.task, resamp, crs = 32717,\n  repetitions = 2, x.axis.breaks = c(-79.065, -79.085),\n  y.axis.breaks = c(-3.970, -4))\n```\n:::\n\n\nTo avoid overlapping axis breaks you might want to set the axis breaks on your own as we did here.\n\nNow we got a list of 2L back from `createSpatialResamplingPlots()`.\nIn the first list we got all the plots, one for each fold.\nSince we used two repetitions and five folds, we have a total of ten instances in it.\n\nThe second list consists of labels for each plot.\nThese are automatically created by `createSpatialResamplingPlots()` and can serve as titles later on.\nNote that for now we just created the `ggplot` objects (stored in the first list of the `plots` object).\nWe still need to plot them!\n\nSingle `ggplot` objects can be plotted by just extracting a certain object from the list, e.g. `plots[[1]][[3]]`.\nThis would plot fold #3 of repetition one.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplots[[1]][[3]]\n```\n\n::: {.cell-output-display}\n![](2018-07-25-visualize-spatial-cv_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=672}\n:::\n:::\n\nHowever usually we want to visualize all plots in a grid.\nFor this purpose we highly recommend to use the `cowplot` package and its function `plot_grid()`.\n\nThe returned objects of `createSpatialResamplingPlots()` are already tailored to be used with this function.\nWe just need to hand over the list of plots and (optional) the labels:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncowplot::plot_grid(plotlist = plots[[\"Plots\"]], ncol = 5, nrow = 2,\n  labels = plots[[\"Labels\"]])\n```\n\n::: {.cell-output-display}\n![](2018-07-25-visualize-spatial-cv_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n# Multiple resample objects\n\n`createSpatialResamplingPlots()` is quite powerful and can also take multiple `resample()` objects as inputs with the aim to compare both.\nA typical use case is to visualize the differences between spatial and non-spatial partitioning.\n\nTo do so, we first create two `resample()` objects (one using \"SpRepCV\", one using \"RepCV\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrdesc1 = makeResampleDesc(\"SpRepCV\", folds = 5, reps = 4)\nr1 = resample(makeLearner(\"classif.qda\"), spatial.task, rdesc1)\nrdesc2 = makeResampleDesc(\"RepCV\", folds = 5, reps = 4)\nr2 = resample(makeLearner(\"classif.qda\"), spatial.task, rdesc2)\n```\n:::\n\n\nNow we can hand over both objects using a named list.\nThis way the list names will also directly be used as a prefix in the resulting plot labels.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplots = createSpatialResamplingPlots(spatial.task,\n  list(\"SpRepCV\" = r1, \"RepCV\" = r2), crs = 32717, repetitions = 1,\n  x.axis.breaks = c(-79.055, -79.085), y.axis.breaks = c(-3.975, -4))\n\ncowplot::plot_grid(plotlist = plots[[\"Plots\"]], ncol = 5, nrow = 2,\n  labels = plots[[\"Labels\"]])\n```\n\n::: {.cell-output-display}\n![](2018-07-25-visualize-spatial-cv_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n# References\n\nBrenning, A. (2012). Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest. In 2012 IEEE International Geoscience and Remote Sensing Symposium. IEEE. https://doi.org/10.1109/igarss.2012.6352393\n",
    "supporting": [
      "2018-07-25-visualize-spatial-cv_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}