{
  "hash": "5a7cf4b024dbf93159b421d94a8cd889",
  "result": {
    "markdown": "---\ntitle: \"Use mlrMBO to optimize via command line\"\nauthors: [\"Jakob Richter\"]\ndate: 2017-03-22\ncategories: [\"R\", \"r-bloggers\"]\ntags: [\"mlrMBO\", \"command-line\", \"rstats\"]\n\ndescription: \"Tutorial on using mlrMBO from the command line\"\n---\n\n\n\n\nMany people who want to apply Bayesian optimization want to use it to optimize an algorithm that is not implemented in **R** but runs on the command line as a shell script or an executable.\n\nWe recently published [**mlrMBO**](https://mlrMBO.mlr-org.com/) on CRAN.\nAs a normal package it normally operates inside of R, but with this post I want to demonstrate how **mlrMBO** can be used to optimize an external application.\nAt the same time I will highlight some issues you can likely run into.\n\nFirst of all we need a bash script that we want to optimize.\nThis tutorial will only run on Unix systems (Linux, OSX etc.) but should also be informative for windows users.\nThe following code will write a tiny bash script that uses `bc` to calculate $sin(x_1-1) + (x_1^2 + x_2^2)$ and write the result \"hidden\" in a sentence (`The result is 12.34!`) in a `result.txt` text file.\n\n### The bash script\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# write bash script\nlines = '#!/bin/bash\nfun ()\n{\n  x1=$1\n  x2=$2\n  command=\"(s($x1-1) + ($x1^2 + $x2^2))\"\n  result=$(bc -l <<< $command)\n}\necho \"Start calculation.\"\nfun $1 $2\necho \"The result is $result!\" > \"result.txt\"\necho \"Finish calculation.\"\n'\nwriteLines(lines, \"fun.sh\")\n# make it executable:\nsystem(\"chmod +x fun.sh\")\n```\n:::\n\n\n### Running the script from R\n\nNow we need a R function that starts the script, reads the result from the text file and returns it.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(stringi)\nrunScript = function(x) {\n  command = sprintf(\"./fun.sh %f %f\", x[['x1']], x[['x2']])\n  error.code = system(command)\n  if (error.code != 0) {\n    stop(\"Simulation had error.code != 0!\")\n  }\n  result = readLines(\"result.txt\")\n  # the pattern matches 12 as well as 12.34 and .34\n  # the ?: makes the decimals a non-capturing group.\n  result = stri_match_first_regex(result,\n    pattern = \"\\\\d*(?:\\\\.\\\\d+)?(?=\\\\!)\")\n  as.numeric(result)\n}\n```\n:::\n\n\nThis function uses `stringi` and _regular expressions_ to match the result within the sentence.\nDepending on the output different strategies to read the result make sense.\nXML files can usually be accessed with `XML::xmlParse`, `XML::getNodeSet`, `XML::xmlAttrs` etc. using `XPath` queries.\nSometimes the good old `read.table()` is also sufficient.\nIf, for example, the output is written in a file like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvalue1 = 23.45\nvalue2 = 13.82\n```\n:::\n\n\nYou can easily use `source()` like that:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nEV = new.env()\neval(expr = {a = 1}, envir = EV)\nas.list(EV)\nsource(file = \"result.txt\", local = EV)\nres = as.list(EV)\nrm(EV)\n```\n:::\n\n\nwhich will return a list with the entries `$value1` and `$value2`.\n\n### Define bounds, wrap function.\n\nTo evaluate the function from within **mlrMBO** it has to be wrapped in **smoof** function.\nThe smoof function also contains information about the bounds and scales of the domain of the objective function defined in a _ParameterSet_.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlrMBO)\n## Loading required package: mlr\n## Loading required package: ParamHelpers\n## Warning message: 'mlr' is in 'maintenance-only' mode since July 2019. Future development will only happen\n## in 'mlr3' (<https://mlr3.mlr-org.com>). Due to the focus on 'mlr3' there might be uncaught bugs meanwhile\n## in {mlr} - please consider switching.\n## Loading required package: smoof\n## Loading required package: checkmate\n## Warning: no DISPLAY variable so Tk is not available\n# Defining the bounds of the parameters:\npar.set = makeParamSet(\n  makeNumericParam(\"x1\", lower = -3, upper = 3),\n  makeNumericParam(\"x2\", lower = -2.5, upper = 2.5)\n)\n# Wrapping everything in a smoof function:\nfn = makeSingleObjectiveFunction(\n  id = \"fun.sh\",\n  fn = runScript,\n  par.set = par.set,\n  has.simple.signature = FALSE\n)\n# let's see if the function is working\ndes = generateGridDesign(par.set, resolution = 3)\ndes$y = apply(des, 1, fn)\ndes\n##   x1   x2         y\n## 1 -3 -2.5 16.006802\n## 2  0 -2.5  5.408529\n## 3  3 -2.5 16.159297\n## 4 -3  0.0  9.756802\n## 5  0  0.0  0.841471\n## 6  3  0.0  9.909297\n## 7 -3  2.5 16.006802\n## 8  0  2.5  5.408529\n## 9  3  2.5 16.159297\n```\n:::\n\n\nIf you run this locally, you will see that the console output generated by our shell script directly appears in the R-console.\nThis can be helpful but also annoying.\n\n### Redirecting output\n\nIf a lot of output is generated during a single call of `system()` it might even crash R.\nTo avoid that I suggest to redirect the output into a file.\nThis way no output is lost and the R console does not get flooded.\nWe can simply achieve that by replacing the `command` in the function `runScript` from above with the following code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n  # console output file output_1490030005_1.1_2.4.txt\n  output_file = sprintf(\"output_%i_%.1f_%.1f.txt\",\n    as.integer(Sys.time()), x[['x1']], x[['x2']])\n  # redirect output with ./fun.sh 1.1 2.4 > output.txt\n  # alternative: ./fun.sh 1.1 2.4 > /dev/null to drop it\n  command = sprintf(\"./fun.sh %f %f > %s\", x[['x1']], x[['x2']], output_file)\n```\n:::\n\n\n\n\n### Start the Optimization\n\nNow everything is set so we can proceed with the usual MBO setup:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nctrl = makeMBOControl()\nctrl = setMBOControlInfill(ctrl, crit = crit.ei)\nctrl = setMBOControlTermination(ctrl, iters = 10)\nconfigureMlr(show.info = FALSE, show.learner.output = FALSE)\nrun = mbo(fun = fn, control = ctrl)\n## Computing y column(s) for design. Not provided.\n## [mbo] 0: x1=-1.35; x2=0.815 : y = 1.77 : 0.0 secs : initdesign\n## [mbo] 0: x1=1.93; x2=-0.485 : y = 4.76 : 0.0 secs : initdesign\n## [mbo] 0: x1=-2.61; x2=-1.66 : y = 9.98 : 0.0 secs : initdesign\n## [mbo] 0: x1=-0.223; x2=0.239 : y = 0.833 : 0.0 secs : initdesign\n## [mbo] 0: x1=0.373; x2=2.22 : y = 4.48 : 0.0 secs : initdesign\n## [mbo] 0: x1=0.763; x2=-0.825 : y = 1.03 : 0.0 secs : initdesign\n## [mbo] 0: x1=2.38; x2=1.31 : y = 8.39 : 0.0 secs : initdesign\n## [mbo] 0: x1=-1.8; x2=-2.42 : y = 8.77 : 0.0 secs : initdesign\n## [mbo] 1: x1=0.18; x2=-0.478 : y = 0.47 : 0.0 secs : infill_ei\n## [mbo] 2: x1=-0.118; x2=-0.806 : y = 0.236 : 0.0 secs : infill_ei\n## [mbo] 3: x1=0.242; x2=-1.39 : y = 1.31 : 0.0 secs : infill_ei\n## [mbo] 4: x1=-0.5; x2=-0.462 : y = 0.535 : 0.0 secs : infill_ei\n## [mbo] 5: x1=-0.109; x2=-0.64 : y = 0.474 : 0.0 secs : infill_ei\n## [mbo] 6: x1=0.161; x2=-0.893 : y = 0.0784 : 0.0 secs : infill_ei\n## [mbo] 7: x1=-3; x2=2.5 : y = 16 : 0.0 secs : infill_ei\n## [mbo] 8: x1=-0.866; x2=-0.878 : y = 0.564 : 0.0 secs : infill_ei\n## [mbo] 9: x1=-0.555; x2=0.939 : y = 0.189 : 0.0 secs : infill_ei\n## [mbo] 10: x1=0.15; x2=0.806 : y = 0.0787 : 0.0 secs : infill_ei\n# The resulting optimal configuration:\nrun$x\n## $x1\n## [1] 0.1609242\n## \n## $x2\n## [1] -0.8925002\n# The best reached value:\nrun$y\n## [1] 0.07842672\n```\n:::\n\n\n### Execute the R script from a shell\n\nAlso you might not want to bothered having to start *R* and run this script manually so what I would recommend is saving all above as an R-script plus some lines that write the output in a JSON file like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(jsonlite)\nwrite_json(run[c(\"x\",\"y\")], \"mbo_res.json\")\n```\n:::\n\n\nLet's assume we saved all of that above as an R-script under the name [`runMBO.R` (actually it is available as a gist)](https://gist.github.com/jakob-r/6be022d49e135c7905fd4c097bc3d376).\n\nThen you can simply run it from the command line:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.bash .cell-code}\nRscript runMBO.R\n```\n:::\n\n\nAs an extra the script in the gist also contains a simple handler for command line arguments.\nIn this case you can define the number of optimization iterations and the maximal allowed time in seconds for the optimization.\nYou can also define the seed to make runs reproducible:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.bash .cell-code}\nRscript runMBO.R iters=20 time=10 seed=3\n```\n:::\n\n\nIf you want to build a more advanced command line interface you might want to have a [look](https://www.slideshare.net/EdwindeJonge1/docopt-user2014) [at](https://github.com/docopt/docopt.R) [docopt](https://cran.r-project.org/package=docopt).\n\n### Clean up\n\nTo clean up all the files generated by this script you can run:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfile.remove(\"result.txt\")\nfile.remove(\"fun.sh\")\nfile.remove(\"mbo_res.json\")\noutput.files = list.files(pattern = \"output_\\\\d+_[0-9_.-]+\\\\.txt\")\nfile.remove(output.files)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}