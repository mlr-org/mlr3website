{
  "hash": "feed6d57384840104ba29ea2ab4f7068",
  "result": {
    "markdown": "---\ntitle: Resampling - Stratified, Blocked and Predefined\ncategories:\n - resampling\n - classification\n - stratification\nauthor:\n  - name: Milan Dragicevic\n  - name: Giuseppe Casalicchio\ndate: 03-30-2020\ndescription: |\n  Apply stratified, block and custom resampling.\naliases:\n  - ../../../gallery/2020-03-30-stratification-blocking/index.html\n---\n\n\n\n\n# Intro\n\nWhen evaluating machine learning algorithms through resampling, it is preferable that each train/test partition will be a representative subset of the whole data set.\nThis post covers three ways to achieve such reliable resampling procedures:\n\n  1. [Stratified resampling](https://mlr3.mlr-org.com/reference/Resampling.html#stratification) for classification problems where each train/test split maintains the target class distribution of the original data set.\n  2. [Block resampling](https://mlr3.mlr-org.com/reference/Resampling.html#grouping-blocking) where a grouping factor determines which observations should be together in train/test splits.\n  3. [Custom resampling](https://mlr3.mlr-org.com/reference/mlr_resamplings_custom.html) using predefined and manually created folds for the train/test splits.\n\n# Prerequisites\n\nWe load the most important packages for this post.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlr3verse)\nlibrary(mlbench)\nlibrary(data.table)\n```\n:::\n\n\nWe initialize the random number generator with a fixed seed for reproducibility.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(7832)\n```\n:::\n\n\n# Stratified resampling\n\nIn classification tasks, the ratio of the target class distribution should be similar in each train/test split, which is achieved by [stratification](https://mlr.mlr-org.com/articles/tutorial/resample.html#stratification-with-respect-to-the-target-variables). This is particularly useful in the case of imbalanced classes and small data sets.\n\nStratification can also be performed with respect to explanatory categorical variables to ensure that all subgroups are represented in all training and test sets.\n\nIn [mlr3](https://mlr3.mlr-org.com), each [`Task`](https://mlr3.mlr-org.com/reference/Task.html) has a slot [`$col_roles`](https://mlr3.mlr-org.com/reference/Task.html#active-bindings).\nThis slot shows general roles certain features will have throughout different stages of the machine learning process.\nAt least, the `$col_roles` slot shows which variables will be used as `feature`s and as the `target`.\nHowever, the `$col_roles` slot can be more diverse and some variables might even serve multiple roles.\nWe can specify the variable used for stratification in `task$col_roles$stratum`.\nThis will be illustrated in the following example using the [`german_credit`](https://mlr3.mlr-org.com/reference/mlr_tasks_german_credit.html) data:\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc = tsk(\"german_credit\")\ntask_gc$col_roles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$feature\n [1] \"age\"                     \"amount\"                  \"credit_history\"          \"duration\"               \n [5] \"employment_duration\"     \"foreign_worker\"          \"housing\"                 \"installment_rate\"       \n [9] \"job\"                     \"number_credits\"          \"other_debtors\"           \"other_installment_plans\"\n[13] \"people_liable\"           \"personal_status_sex\"     \"present_residence\"       \"property\"               \n[17] \"purpose\"                 \"savings\"                 \"status\"                  \"telephone\"              \n\n$target\n[1] \"credit_risk\"\n\n$name\ncharacter(0)\n\n$order\ncharacter(0)\n\n$stratum\ncharacter(0)\n\n$group\ncharacter(0)\n\n$weight\ncharacter(0)\n```\n:::\n:::\n\n\nWe use the target feature called `credit_risk` to specify stratification with respect to the target variable:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc$col_roles$stratum = \"credit_risk\"\n# alternatively task_gc$col_roles$stratum = task_gc$col_roles$target\n```\n:::\n\n\nAfter the specification of `task$col_roles$stratum`, the active binding [`task$strata`](https://mlr3.mlr-org.com/reference/Task.html#active-bindings) will show the number of observations in each group and the corresponding row id's:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc$strata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     N                row_id\n1: 700       1,3,4,6,7,8,...\n2: 300  2, 5,10,11,12,14,...\n```\n:::\n:::\n\n\nSpecify 3-fold cross validation and instantiate the resampling on the task:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncv3 = rsmp(\"cv\", folds = 3)\ncv3$instantiate(task_gc)\ncv3$instance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      row_id fold\n   1:      7    1\n   2:      8    1\n   3:      9    1\n   4:     17    1\n   5:     22    1\n  ---            \n 996:    959    3\n 997:    967    3\n 998:    980    3\n 999:    984    3\n1000:    999    3\n```\n:::\n:::\n\n\nCheck if the target class distribution is similar in each fold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndt = merge(cv3$instance, task_gc$data()[, row_id := .I], by = \"row_id\")\ndt[, .(class_ratio = sum(credit_risk == \"bad\") /\n  sum(credit_risk == \"good\")), by = fold]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   fold class_ratio\n1:    2   0.4291845\n2:    3   0.4291845\n3:    1   0.4273504\n```\n:::\n:::\n\n\nAnd compare it with the target class distribution from the whole data set:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndt[, .(class_ratio = sum(credit_risk == \"bad\") / sum(credit_risk == \"good\"))]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   class_ratio\n1:   0.4285714\n```\n:::\n:::\n\n\nNote that the variable used for stratification does not necessarily have to be the target class.\nIn fact, multiple categorical features can be used for stratification to maintain their frequency distribution in each fold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc$col_roles$stratum = c(\"housing\", \"telephone\")\ntask_gc$strata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     N                      row_id\n1: 280        1,13,20,21,26,30,...\n2: 433        2, 3, 7, 9,10,14,...\n3:  47   4,  5, 45, 76,134,192,...\n4:  61        6,19,37,55,63,69,...\n5:  63   8, 48, 60, 72, 96,100,...\n6: 116       11,12,15,22,23,28,...\n```\n:::\n:::\n\n\nTo illustrate if stratification based on multiple categorical features works, we need to instantiate the CV folds again as we changed the features used for stratification:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncv3$instantiate(task_gc)\ncv3$instance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      row_id fold\n   1:     13    1\n   2:     21    1\n   3:     31    1\n   4:     33    1\n   5:     43    1\n  ---            \n 996:    945    3\n 997:    973    3\n 998:    974    3\n 999:    986    3\n1000:    993    3\n```\n:::\n:::\n\n\nAgain, we check the relative frequency of observations in each group (combination of `housing` and `telephone`) across all folds:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndt = merge(cv3$instance, task_gc$data()[, row_id := .I], by = \"row_id\")\ndt = dt[, .(freq = .N), by = list(fold, housing, telephone)]\ndt = dcast(dt, housing + telephone ~ fold)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing 'freq' as value column. Use 'value.var' to override\n```\n:::\n\n```{.r .cell-code}\ndt[, c(3:5) := lapply(.SD, function(x) x / sum(x)), .SDcols = 3:5]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    housing                 telephone          1          2          3\n1: for free                        no 0.11607143 0.11711712 0.11480363\n2: for free yes (under customer name) 0.06250000 0.06306306 0.06344411\n3:     rent                        no 0.43154762 0.43243243 0.43504532\n4:     rent yes (under customer name) 0.27976190 0.27927928 0.28096677\n5:      own                        no 0.04761905 0.04804805 0.04531722\n6:      own yes (under customer name) 0.06250000 0.06006006 0.06042296\n```\n:::\n:::\n\n\nAnd compare it with the relative frequency from the whole data set:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc$data()[, .(freq = .N / max(.I)),\n  by = list(housing, telephone)\n][order(housing, telephone), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    housing                 telephone       freq\n1: for free                        no 0.11681772\n2: for free yes (under customer name) 0.06415479\n3:     rent                        no 0.43300000\n4:     rent yes (under customer name) 0.28084253\n5:      own                        no 0.04895833\n6:      own yes (under customer name) 0.06106106\n```\n:::\n:::\n\n\nIt is evident that in each fold, the combination of `housing` and `telephone` have similar frequencies that also coincide with the frequencies from the whole data set.\n\n# <a id=\"block\"></a>Block resampling\n\nAn additional concern when specifying resampling is respecting the natural grouping of the data.\nBlocking refers to the situation where subsets of observations belong together and must not be separated during resampling. Hence, for one train/test set pair the entire block is either in the training set or in the test set.\n\nThe following example is based on the [BreastCancer](https://www.rdocumentation.org/packages/mlbench/versions/2.1-1/topics/BreastCancer) data set from the [mlbench](https://cran.r-project.org/package=mlbench) package:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(BreastCancer, package = \"mlbench\")\ntask_bc = as_task_classif(BreastCancer, target = \"Class\", positive = \"malignant\")\n```\n:::\n\n\nIn the [BreastCancer](https://www.rdocumentation.org/packages/mlbench/versions/2.1-1/topics/BreastCancer) data set, for example, several observations have the same \"Id\" (Sample code number) which implies these are samples taken from the same patient at different times.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Let's count how many observation actually have the same Id more than once\nsum(table(BreastCancer$Id) > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 46\n```\n:::\n:::\n\n\nThere are 46 Id's with more than one observation (row).\n\nThe model trained on this data set will be used to predict cancer status of new patients.\nHence, we have to make sure that each `Id` occurs exactly in one fold, so that all observations with the same `Id` should be either used for training or for evaluating the model.\nThis way, we get less biased performance estimates via k-fold cross validation.\nThe following example will illustrate block cross validation which can be achieved by specifying a blocking factor in the [`task$col_roles$group`](https://mlr3.mlr-org.com/reference/Task.html#active-bindings) slot:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Use Id column as block factor\ntask_bc$col_roles$group = \"Id\"\n# Remove Id from feature\n# task_bc$col_roles$feature = setdiff(task_bc$col_roles$feature, \"Id\")\ncv5 = rsmp(\"cv\", folds = 5)\nset.seed(123)\ncv5$instantiate(task_bc)\ncv5$instance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      row_id fold\n  1: 1016277    1\n  2: 1044572    1\n  3: 1049815    1\n  4: 1050718    1\n  5: 1054590    1\n ---             \n641: 1369821    5\n642: 1371026    5\n643: 1371920    5\n644:  714039    5\n645:  841769    5\n```\n:::\n:::\n\n\nIn this case, the `row_id` column of the `cv5$instance` slot refers to values of the grouping variable \"Id\".\nAdditionally, the number of rows of the `cv5$instance` is the same as the number of unique groups:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall(cv5$instance$row_id %in% BreastCancer$Id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nnrow(cv5$instance) == length(unique(BreastCancer$Id))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIf the specified blocking groups are respected, each `Id` appears only in exactly one fold. To inspect if blocking was successful when generating the folds we count how often each `Id` appears in a specific fold and print the `Id`s that appear in more than one fold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndt = merge(task_bc$data(), cv5$instance, by.x = \"Id\", by.y = \"row_id\")\ndt = dt[, .(unique_folds = length(unique(fold))), by = Id]\ndt[unique_folds > 1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpty data.table (0 rows and 2 cols): Id,unique_folds\n```\n:::\n:::\n\n\nAs expected, the table is empty as there are no Id's present in more than one fold.\n\n# Resampling with predefined folds\n\nIn some use cases, it might be necessary to use predefined folds. When using k-fold cross validation without repetition this can be achieved by manually creating a feature used to denote folds and assigning it to the [`task$col_roles$group`](https://mlr3.mlr-org.com/reference/Task.html#active-bindings) slot.\nFirst, we create a vector that contains 5 predefined folds:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfolds = sample(rep(1:5, length.out = nrow(BreastCancer)),\n  size = nrow(BreastCancer),\n  replace = F\n)\nhead(folds, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 2 4 1 5 2 5 3 1 5 4 3 3 4 5 3 3 5 2 4\n```\n:::\n\n```{.r .cell-code}\ntable(folds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfolds\n  1   2   3   4   5 \n140 140 140 140 139 \n```\n:::\n:::\n\n\nThis vector is now added to the data set and will be used as grouping factor just as when defining [block resampling](#block):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_bc = TaskClassif$new(\n  id = \"BreastCancer\",\n  backend = data.frame(BreastCancer, foldIds = as.factor(folds)),\n  target = \"Class\",\n  positive = \"malignant\"\n)\ntask_bc$col_roles$group = \"foldIds\"\n# Remove \"foldIds\" from features\n# task_bc$col_roles$feature = setdiff(task_bc$col_roles$feature, \"foldIds\")\n```\n:::\n\n\nWe now instantiate a 5-fold CV that will respect the predefined folds:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncv5 = rsmp(\"cv\", folds = 5)\ncv5$instantiate(task_bc)\ncv5$instance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   row_id fold\n1:      1    1\n2:      2    2\n3:      3    3\n4:      4    4\n5:      5    5\n```\n:::\n:::\n\n\nSince we have only five predefined folds, the `cv5$instance` data table has five rows and shows which of our `foldIds` values (contained in the `row_id` column) will belong to which instantiated fold.\nTo check if the predefined groups are respected, we count how often each `foldIds` appears in a specific fold:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndt = merge(task_bc$data(), cv5$instance, by.x = \"foldIds\", by.y = \"row_id\")\ndt[, .(unique_folds = length(unique(fold))), by = foldIds]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   foldIds unique_folds\n1:       1            1\n2:       2            1\n3:       3            1\n4:       4            1\n5:       5            1\n```\n:::\n:::\n\n\nThere are five groups and each `foldIds` appears only in exactly one fold.\nThis means that each instantiated fold corresponds to one of the predefined folds.\n\nThe previous example does not cover how to perform repeated k-fold CV or time series CV with predefined indices.\nThis is possible via the [`mlr_resamplings_custom`](https://mlr3.mlr-org.com/reference/mlr_resamplings_custom.html) to which a list of predefined train and test indices can be assigned.\nIn the following example, a custom resampling is created using indices created by [`caret::createMultiFolds()`](https://www.rdocumentation.org/packages/caret/topics/createMultiFolds):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask_gc = tsk(\"german_credit\")\ntrain_ind = caret::createMultiFolds(task_gc$truth(), k = 5, times = 10)\ntest_ind = lapply(train_ind, function(x) setdiff(1:task_gc$nrow, x))\nrc = rsmp(\"custom\")\nrc$instantiate(task_gc, train_ind, test_ind)\n```\n:::\n\n\nWe now check if the instantiated custom resampling contains the intended folds:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# check it for the first fold\nall.equal(train_ind[[1]], rc$train_set(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# check it for all folds\nunlist(lapply(1:rc$iters, function(i) all.equal(train_ind[[i]], rc$train_set(i))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[24] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[47] TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\n# Conclusions\n\nThis post shows how to control the resampling process when using [mlr3](https://mlr3.mlr-org.com) in order to account for data specificities.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}