{
  "hash": "5103a49bc9a1fb6923b766eadb9d0767",
  "result": {
    "markdown": "---\ntitle: \"Parallel Computing with Rush\"\ndescription: |\n  Run a centralized parallel computing network with the `rush` package.\nauthor:\n  - name: Marc Becker\n    url: https://github.com/be-marc\ndate: 2023-10-23\nimage: cover.jpg\nbibliography: ../../bibliography.bib\n---\n\n\n\n\n\n\n\n# Scope\n\nParallel computing plays an important role in machine learning, especially as the size of datasets and the computational intensity of algorithms increase.\nThis trend necessitates the distribution of computing tasks across multiple workers.\nIn this context, we present `rush`, our novel framework for parallel and distributed computing in R.\n`rush` enables the parallelization of arbitrary R expressions in a network of workers.\nThe framework implements a queue system and an efficient data store based on [Redis](https://redis.io).\nIt integrates the [future](https://cran.r-project.org/package=future) package to start workers on the local machine or remote machines.\nRush is engineered to impose minimal overhead, with the aim of a few milliseconds per task, and is optimized for both rapid and long-running tasks.\nThe package is designed to be lightweight and easy to use, with a simple interface and minimal dependencies.\nWe integrate `rush` into our optimization packages [bbotk](https://bbotk.mlr-org.com) and [mlr3tuning](https://mlr3tuning.mlr-org.com) but still keep it as a general-purpose package.\n\nWe start the article with an overview of the network architecture of the package.\nThen we will look at how to use the package to parallelize a simple task.\nNext, we will explain various features of the package.\nFinally, we will look at how to use the package to parallelize a large-scale hyperparameter optimization.\n\n# Related Work\n\nAs multi-core processors became commonplace in the 2000s, there was a growing need to utilize these resources effectively for computational tasks in R.\nThe first packages to address this need were [snow](https://cran.r-project.org/package=snow) and [multicore](https://cran.r-project.org/package=multicore).\nWith R version 2.14.0 (released in 2011), parallel computing capabilities were integrated into the base R system through the `parallel` package.\nThe functions `parallel::clapply()` and `parallel::parLapply()` are parallel versions of the `lapply()` function for multicore and cluster computing, respectively.\nBoth functions are widely used in R packages but have some limitations.\nThe R session is blocked until all tasks are finished and it is not possible to retrieve partial results.\nMoreover, load balancing can be an issue when the tasks have different runtimes.\n\nThe landscape further evolved with the release of the `future` package in 2016, which provided a unified and flexible parallel computing interface in R, supporting various backends such as `multisession`, `multicore`, and `callr`.\nThe [future.apply](https://cran.r-project.org/package=future.apply) package implements parallel versions of the `*apply()` family functions, compatible with the `future` backends.\n\nWith the rise of high-performance computing (HPC) clusters, the [batchtools](https://cran.r-project.org/package=batchtools) package was developed to facilitate the execution of long-running tasks on these systems.\nThe communication between the main process and the workers runs completely over the file system.\nA notable feature of the package is the assistance in conducting large-scale computer experiments.\nA more recent development in distributed computing is the [crew](https://cran.r-project.org/package=crew) package.\nThe package is designed for long-running tasks in distributed systems, ranging from traditional high-performance clusters to cloud computing platforms.\nA drawback of both systems is the high overhead per task.\n\nThe [rrq](https://github.com/mrc-ide/rrq) package is a task queue system for R using Redis.\nIt addresses the limitations of the packages by providing a non-blocking interface to parallel computing and keeping the overhead per task low.\nThe package allows non-interacting queues with priority levels within a queue and dependencies among tasks.\nThe package has an advanced error-handling mechanism, heavily influencing the heartbeat mechanism of `rush`.\n\nRush aligns closely with `rrq` but differentiates itself with its integration into our optimization packages packages `botk` and `mlr3tuning`.\nThis includes a data structure in Redis that can be efficiently converted to a [`data.table::data.table()`](https://www.rdocumentation.org/packages/data.table/topics/data.table) and a cache mechanism that minimizes the number of read and write operations in the R session.\nMoreover, the start of workers with minimal user configuration is integrated with the `future` package.\nLooking ahead, rush allows a decentralized network architecture devoid of a central controller.\nThis allows the implementation of recently developed optimization algorithms such as Asynchronous Decentralized Bayesian Optimization [@Egele2023].\nFinally, the availability of the package on CRAN is a significant consideration for us.\n\n::: {.callout-note}\n\n## Question\n\n* Maybe we can elaborate more on the differences between `rrq` and `rush`?\n* What could be an advantage for the normal user?\n* The seamless integration with `bbotk` and `mlr3tuning` is only a big advantage for us.\n\n:::\n\n\n# Install\n\nThere are several options to install Redis depending on your operating system.\nYou can find instructions on how to install Redis on [redis.io](https://redis.io/docs/install/install-redis/).\nThe `rush` package is not yet on CRAN.\nYou can install the development version from GitHub with [pak](https://cran.r-project.org/package=pak).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npak::pkg_install(\"mlr-org/rush\")\n```\n:::\n\n\n`rush` is designed to be light on dependencies.\nIt utilizes a select few packages to establish its functionality:\n\n* `redux` - This package is integral to rush, facilitating robust communication with the Redis server for task queuing and data storage operations.\n* `callr` - Enables rush to maintain a heartbeat process, essential for monitoring the status of remote workers.\n* `future` - Provides the core mechanism for initiating worker processes, whether they are on local or remote machines.\n\n# Rush Network\n\nThe rush network is orchestrated through a combination of a controller and multiple workers (as illustrated in @fig-rush).\nThe controller initializes the system and starts the workers (@sec-controller).\nThis stage prepares the environment for task processing which includes loading the function to be evaluated and any required packages.\nThe controller pushes tasks to the queue and retrieves their outcomes (@sec-start-workers).\nThe workers pop tasks from the queue, evaluate them, and push the results to the database.\nA task life cycle consists of four states: \"queued\", \"running\", \"finished\", and \"failed\".\nTasks initially enter a 'queued' state, awaiting processing (@sec-push-task).\nThey remain in this state until a worker is available to handle them.\nWhen a worker picks up a task, its status transitions to 'running'.\nThis stage marks the active processing of the task.\nUpon completion, a task's state is updated to 'finished', and its result is stored in the database (@sec-retrieve-results).\nIn cases where a task encounters an error or issue, its state is marked as 'failed'.\n\n![Centralized rush network](rush.png){#fig-rush width=100%}\n\nThe architecture of a rush centralized rush network.\n\n## Example\n\n\nTo demonstrate the core capabilities of `rush`, we present a simple, practical example utilizing the `mlr3` package for machine learning.\nThe example involves the assessment of a Support Vector Machine (SVM) model performance on the widely-used `spam` dataset.\nWe first define a function, `evaluate_svm()`, that will be dispatched to the workers for execution.\nThis function is designed to accept two parameters: `cost` and `gamma`.\nThese parameters represent the cost and the gamma hyperparameters of the SVM model, respectively.\nInside `evaluate_svm`, the SVM model is trained on the `spam` dataset using the provided `cost` and `gamma` values.\nAfter training the model, `evaluate_svm` computes the classification error, which serves as the performance metric.\nThe function concludes by returning the classification error.\nThis returned value is then captured by `rush`, which manages the collection and storage of results from all the workers.\nBy employing `rush`, we can parallelize the evaluation of the SVM model over a grid of `cost` and `gamma` values, significantly accelerating the hyperparameter tuning process.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlr3)\nlibrary(mlr3learners)\n\ntask = tsk(\"spam\")\nsplits = partition(task)\nlearner = lrn(\"classif.svm\", type = \"C-classification\", kernel = \"radial\")\n\neval_svm = function(cost, gamma, ...) {\n  learner$param_set$set_values(cost = cost, gamma = gamma)\n  learner$train(task, row_ids = splits$train)\n  pred = learner$predict(task, row_ids = splits$test)\n  list(ce = pred$score())\n}\n```\n:::\n\n\n## Controller {#sec-controller}\n\nThe `Rush` instance is the controller of the centralized network.\nThe controller starts and stops the workers, pushes tasks to the queue and fetches their results.\nThe controller is initialized with the function `rsh()`.\nThe `network_id` argument is used to identify the controller and workers belonging to the same network.\nThe `config` argument is a list of Redis configuration options used by the `redux` package to connect to the Redis server.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(rush)\n\nconfig = redux::redis_config()\nrush = rsh(network_id = \"svm\", config = config)\nrush\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Rush>\n* Running Workers: 0\n* Queued Tasks: 0\n* Queued Priority Tasks: 0\n* Running Tasks: 0\n* Finished Tasks: 0\n* Failed Tasks: 0\n```\n:::\n:::\n\n\n::: {.callout-note}\n\n## Question\n\n* We could create a `rush_plan(config)` function that rush controllers could use to connect to the Redis server.\n\n:::\n\n\n## Worker {#sec-worker}\n\nThe `RushWorker` represents a worker in the rush network.\nA worker inherits from the `Rush` controller class.\nIt adds methods to pop tasks from the queue and push results to the database.\nOn worker runs a loop that fetches a task from the queue, evaluates the task and pushes the results back to the database.\nThe default worker loop is `fun_loop`.\nThis function fetches a task from the queue, evaluates the user-defined function `fun`, pushes the results back to redis and waits for the next task.\nUsually, we do not need to define a custom worker loop and pass the `fun` argument to the `$start_workers()` method.\n\nWorkers can be started on the local machine or a remote machine.\nA local worker runs on the same machine as the controller.\nA remote worker runs on a different machine.\nWe distinguish between local and remote workers because the mechanism to kill and monitor a remote worker is different.\n\n## Start Workers {#sec-start-workers}\n\nNow we are ready to start the workers.\nThe `$start_workers()` method starts the workers with the `future` package.\nWe pass the `host = \"local\"` argument to mark the workers as local.\nOptionally, we can pass a `n_workers` argument to specify the number of workers.\nIf we do not pass a `n_workers` argument, the number of workers is set to available future workers.\nIf `fun` depends on global variables, we can pass them to the `globals` argument.\nOur `eval_svm()` function depends on the `learner`, `task` and `splits` objects.\nPackages that are needed by `fun` can be passed to the `packages` argument.\nWe need the `mlr3`, `mlr3learners` and `e1071` packages.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfuture::plan(\"multisession\")\n\nrush$start_workers(\n  worker_loop = fun_loop,\n  n_workers = 2,\n  globals = c(\"learner\", \"task\", \"splits\"),\n  packages = c(\"mlr3\", \"mlr3learners\", \"e1071\"),\n  host = \"local\",\n  fun = eval_svm)\n\nrush\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Rush>\n* Running Workers: 2\n* Queued Tasks: 0\n* Queued Priority Tasks: 0\n* Running Tasks: 0\n* Finished Tasks: 0\n* Failed Tasks: 0\n```\n:::\n:::\n\n\n::: {.callout-note}\n\n## Question\n * We could simplify `$start_workers()` by hiding the `worker_loop` argument.\nBut `bbotk` and `mlr3tuning` use a custom worker loop.\n * We could replace `future` and just use `parallely`.\n * We could replace the `host` argument with something like `Sys.info()[[\"nodename\"]]`.\n\n:::\n\nOn a remote machine, we need to start the workers manually or use the future `cluster` backend.\nWe distinguish between local and remote workers because the mechanism to kill and monitor a remote worker is different.\nSee the sections on heartbeats and start scripts for more information.\n\n## Push Task {#sec-push-task}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nkeys = rush$push_tasks(list(list(cost = 1e-4, gamma = 1e-4)))\n```\n:::\n\n\nThe `$push_tasks()` method pushes returns the keys of the pushed tasks.\nPushing a task is non-blocking.\nWe can wait for a task to finish with the `$await_tasks()` method.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$await_tasks(keys)\n```\n:::\n\n\nThe method blocks until all tasks in `keys` are finished.\n\n## Retrieve Results {#sec-retrieve-results}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$fetch_finished_tasks()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    cost gamma   pid                            worker_id        ce    state                                 keys\n   <num> <num> <int>                               <char>     <num>   <char>                               <char>\n1: 1e-04 1e-04 50299 9b544388-950c-49a4-8189-0c03c40a92fe 0.3939394 finished e6d1f6b7-d702-4486-8542-fd29ac8ec3ec\n```\n:::\n:::\n\n\nThe `$fetch_*()` methods retrieve data from the Redis database.\nA matching method is defined for each task state e.g. `$fetch_running_tasks()` and `$fetch_finished_tasks()`.\nIf only the result of the function evaluation is needed, `$fetch_results()` and `$fetch_latest_results()` are faster.\nThe methods `$fetch_results()` and `$fetch_finished_tasks()` cache the already queried data.\n\nThe `$block_*()` variants wait until a new result is available.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$push_tasks(list(list(cost = 1e-4, gamma = 1e-4)))\nrush$block_latest_results()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          ce\n       <num>\n1: 0.3939394\n```\n:::\n:::\n\n\n## Stop Workers\n\nLocal and remote workers can be terminated with the `$stop_workers(type = \"terminate\")` method.\nThe workers evaluate the currently running task and then terminate.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$stop_workers(type = \"terminate\")\n```\n:::\n\n\nThe option `type = \"kill\"` stops the workers immediately.\nKilling a local worker is done with the `tools::pskill()` function.\nRemote workers are killed by pushing a kill signal to the heartbeat process.\nWithout a heartbeat process a remote worker cannot be killed (see @sec-heartbeat).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$stop_workers(type = \"kill\")\n```\n:::\n\n\n\n# Advanced Functionality\n\n## Heartbeats {#sec-heartbeat}\n\nThe heartbeat is a mechanism to monitor the status of remote workers in distributed computing systems.\nThe mechanism consists of a heartbeat key with a set [expiration timeout](https://redis.io/commands/expire/) and a dedicated heartbeat process that refreshes the timeout periodically.\nThe heartbeat process is started with `callr` and is linked to main process of the worker.\nIn the event of a worker's failure, the associated heartbeat process also ceases to function, thus halting the renewal of the timeout.\nThe absence of the heartbeat key acts as an indicator to the controller that the worker is no longer operational.\nConsequently, the controller updates the worker's status to `\"lost\"`.\n\nHeartbeats are initiated upon worker startup by specifying the `heartbeat_period` and `heartbeat_expire` parameters.\nThe `heartbeat_period` defines the frequency at which the heartbeat process will update the timeout.\nThe `heartbeat_expire` sets the duration, in seconds, before the heartbeat key expires.\nThe expiration time should be set to a value greater than the heartbeat period to ensure that the heartbeat process has sufficient time to refresh the timeout.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$start_workers(\n  worker_loop = fun_loop,\n  n_workers = 2,\n  globals = c(\"learner\", \"task\", \"splits\"),\n  packages = c(\"mlr3\", \"mlr3learners\", \"e1071\"),\n  host = \"remote\",\n  heartbeat_period = 1,\n  heartbeat_expire = 3,\n  fun = eval_svm)\n\nrush$push_tasks(list(list(cost = 1e-3, gamma = 1e-3)))\nrush$block_finished_tasks()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    cost gamma   pid                            worker_id        ce    state                                 keys\n   <num> <num> <int>                               <char>     <num>   <char>                               <char>\n1: 1e-04 1e-04 50299 9b544388-950c-49a4-8189-0c03c40a92fe 0.3939394 finished e6d1f6b7-d702-4486-8542-fd29ac8ec3ec\n2: 1e-03 1e-03 50307 02d608c2-d310-44c1-81b0-6b09111a180f 0.3939394 finished 87a34a0d-65e2-4c9b-962c-9f5b6e6eed09\n```\n:::\n:::\n\n\n\nThe heartbeat process is also the only way to kill a remote worker.\nThe `$stop_workers(type = \"kill\")` method pushes a kill signal to the heartbeat process.\nThe heartbeat process terminates the main process of the worker.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$stop_workers(type = \"kill\")\n```\n:::\n\n\n## Error Handling\n\nWhen evaluating tasks in a distributed system, many things can go wrong.\nSimple R errors in the worker loop are caught and written to the archive.\nThe task is marked as `\"failed\"`.\nIf the connection to a worker is lost, it looks like a task is `\"running\"` forever.\nThe methods `$detect_lost_workers()` and `$detect_lost_tasks()` detect lost workers.\nRunning these methods periodically adds a small overhead.\n\n::: {.callout-note}\n\n# Question\n\n* Use `mlr3misc::encapsulate()`?\nAllows using `callr` for encapsulation.\nWorkers would not get lost.\nBut we would saves log messages twice since lgr messages are directly written to the data base by rush.\nWe have encapsulation already already in mlr3.\n\n:::\n\n## Logging\n\nThe worker logs all messages written with the `lgr` package to the data base.\nThe `lgr_thresholds` argument defines the logging level for each logger e.g. `c(rush = \"debug\")`.\nSaving log messages adds a small overhead but is useful for debugging.\nBy default, no log messages are stored.\n\n## Start Script\n\nWe are not limited to start workers with the `future` package.\nA work can be started manually with a script on a remote machine.\nThe only requirement is that the machine has access to the Redis server and can run R scripts.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrush$create_worker_script()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nINFO  [18:26:41.198] [rush] Start worker with:\nINFO  [18:26:41.224] [rush] Rscript -e 'rush::start_worker(svm, url = \"redis://127.0.0.1:6379\")'\nINFO  [18:26:41.230] [rush] See ?rush::start_worker for more details.\n```\n:::\n:::\n\n\n\n## Reproducibility\n\n::: {.callout-note}\n\n# Question\n\n* How to pass a seed to the workers?\n* The results of hyperband are not reproducible. See [Optuna](https://optuna.readthedocs.io/en/stable/faq.html#how-can-i-obtain-reproducible-optimization-results).\n:::\n\n## Queues\n\nRush uses a shared queue and a queue for each worker.\nThe shared queue is used to push tasks to the workers.\nThe first worker that pops a task from the shared queue evaluates the task.\nThe worker queues are used to push tasks to specific workers.\n\n## Rush Data Store {#sec-data-store}\n\nRush writes a task and its result and additional meta information into a Redis [hash](https://redis.io/docs/data-types/hashes/).\n\n```\nkey : xs | ys | extra | state\n```\n\nThe key of the hash identifies the task in `rush`.\nThe fields are written by different methods, e.g. `$push_result()` writes `ys` when the result is available.\nThe value of a field is a serialized list e.g. unserializing `xs` gives `list(x1 = 1, x2 = 2)`.\nThis data structure allows quickly converting a hash into a row and joining multiple hashes into a table.\nFor example, three hashes from the above example are converted to the following table.\n\n\n| key | x1 | x2 | y | timestamp | state    |\n|-----|----|----|---|-----------|----------|\n| 1.. |  3 |  4 | 7 |  12:04:11 | finished |\n| 2.. |  1 |  4 | 5 |  12:04:12 | finished |\n| 3.. |  1 |  1 | 2 |  12:04:13 | finished |\n\n\nNotice that a value of a field can store multiple columns of the table.\n\nThe methods `$push_tasks()` and `$push_results()` write into multiple hashes.\nFor example, `$push_tasks(xss = list(list(x1 = 1, x2 = 2), list(x1 = 2, x2 = 2))` writes `xs` in two hashes.\n\n# Benchmark\n\n# Large Example\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(paradox)\n\nsearch_space = ps(\n  cost   = p_dbl(1e-4, 1e4, logscale = TRUE),\n  gamma  = p_dbl(1e-4, 1e4, logscale = TRUE)\n)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}