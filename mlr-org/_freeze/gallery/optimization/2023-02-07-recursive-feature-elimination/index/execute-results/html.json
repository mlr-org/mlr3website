{
  "hash": "f028cc06674668932e70038a38ea6144",
  "result": {
    "markdown": "---\ntitle: \"Recursive Feature Elimination on the Sonar Data Set\"\ndescription: |\n  Utilize the built-in feature importance of models.\ncategories:\n  - feature selection\n  - classification\nauthor:\n  - name: Marc Becker\n    url: https://github.com/be-marc\ndate: 2023-02-07\nbibliography: ../../bibliography.bib\nknitr:\n  opts_chunk:\n    R.options:\n      datatable.print.nrows: 12\n---\n\n\n\n\n\n\n# Scope\n\nFeature selection is the process of finding an optimal subset of features in order to improve the performance, interpretability and robustness of machine learning algorithms.\nIn this article, we introduce the wrapper feature selection method *Recursive Feature Elimination*.\n[Wrapper methods](https://mlr3book.mlr-org.com/feature-selection.html#fs-wrapper) iteratively select features that optimize a performance measure.\nAs an example, we will search for the optimal set of features for a [`gradient boosting machine`](https://mlr3extralearners.mlr-org.com/reference/mlr_learners_classif.gbm.html) and [`support vector machine`](https://mlr3learners.mlr-org.com/reference/mlr_learners_classif.svm.html) on the [`Sonar`](https://mlr3.mlr-org.com/reference/mlr_tasks_pima.html) data set.\nWe assume that you are already familiar with the basic building blocks of the [mlr3 ecosystem](https://mlr-org.com/ecosystem.html).\nIf you are new to feature selection, we recommend reading the [feature selection chapter](https://mlr3book.mlr-org.com/feature-selection.html) of the mlr3book first.\n\n# Recursive Feature Elimination\n\nRecursive Feature Elimination (RFE) is a widely used feature selection method for high-dimensional data sets.\nThe idea is to iteratively remove the least predictive feature from a model until the desired number of features is reached.\nThis feature is determined by the built-in feature importance method of the model.\nCurrently, RFE works with support vector machines (SVM), decision tree algorithms and gradient boosting machines (GBM).\nSupported learners are tagged with the `\"importance\"` property.\nFor a full list of supported learners, see the learner page on the [mlr-org website](https://mlr-org.com/learners.html) and search for `\"importance\"`.\n\n@guyon_gene_2002 developed the RFE algorithm for SVMs (SVM-RFE) to select informative genes in cancer classification.\nThe importance of the features is given by the weight vector of a linear support vector machine.\nThis method was later extended to other machine learning algorithms.\nThe only requirement is that the models can internally measure the feature importance.\nThe random forest algorithm offers multiple options for measuring feature importance.\nThe commonly used methods are the mean decrease in accuracy (MDA) and the mean decrease in impurity (MDI).\nThe MDA measures the decrease in accuracy for a feature if it was randomly permuted in the out-of-bag sample.\nThe MDI is the total reduction in node impurity when the feature is used for splitting.\nGradient boosting algorithms like [`XGBoost`](https://mlr3learners.mlr-org.com/reference/mlr_learners_classif.xgboost.html), [`LightGBM`](https://mlr3extralearners.mlr-org.com/reference/mlr_learners_classif.lightgbm.html) and [`GBM`](https://mlr3extralearners.mlr-org.com/reference/mlr_learners_classif.gbm.html) use similar methods to measure the importance of the features.\n\nResampling strategies can be combined with the algorithm in different ways.\nThe frameworks scikit-learn [@pedregosa_scikit-learn_2011] and caret [@kuhn_building_2008] implement a variant called recursive feature elimination with cross-validation (RFE-CV) that estimates the optimal number of features with cross-validation first.\nThen one more RFE is carried out on the complete dataset with the optimal number of features as the final feature set size.\nThe RFE implementation in mlr3 can rank and aggregate importance scores across resampling iterations.\nWe will explore both variants in more detail below.\n\n[mlr3fselect](https://mlr3fselect.mlr-org.com) is the feature selection package of the [mlr3 ecosystem](https://mlr-org.com/ecosystem.html).\nIt implements the [`RFE`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfe.html) and [`RFE-CV`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfecv.html) algorithm.\nWe load all packages of the ecosystem with the [`mlr3verse`](https://mlr3verse.mlr-org.com/reference/mlr3verse-package.html) package.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlr3verse)\n```\n:::\n\n\nWe retrieve the [`RFE`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfe.html) optimizer with the [`fs()`](https://mlr3fselect.mlr-org.com/reference/fs.html) function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer = fs(\"rfe\",\n  n_features = 1,\n  feature_number = 1,\n  aggregation = \"rank\")\n```\n:::\n\n\nThe algorithm has multiple control parameters.\nThe optimizer stops when the number of features equals `n_features`.\nThe parameters `feature_number`, `feature_fraction` and `subset_size` determine the number of features that are removed in each iteration.\nThe `feature_number` option removes a fixed number of features in each iteration, whereas `feature_fraction` removes a fraction of the features.\nThe `subset_size` argument is a vector that specifies exactly how many features are removed in each iteration.\nThe parameters are mutually exclusive and the default is `feature_fraction = 0.5`.\nUsually, RFE fits a new model in each resampling iteration and calculates the feature importance again.\nWe can deactivate this behavior by setting `recursive = FALSE`.\nThe selection of feature subsets in all iterations is then based solely on the importance scores of the first model trained with all features.\nWhen running an RFE with a resampling strategy like cross-validation, multiple models and importance scores are generated.\nThe `aggregation` parameter determines how the importance scores are aggregated.\nThe option `\"rank\"` ranks the importance scores in each iteration and then averages the ranks of the features.\nThe feature with the lowest average rank is removed.\nThe option `\"mean\"` averages the importance scores of the features across the iterations.\nThe `\"mean\"` should only be used if the learner's importance scores can be reasonably averaged.\n\n# Task\n\nThe objective of the [`Sonar`](https://mlr3.mlr-org.com/reference/mlr_tasks_sonar.html) data set is to predict whether a sonar signal bounced off a metal cylinder or a rock.\nThe data set includes 60 numerical features (see @fig-features).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask = tsk(\"sonar\")\n```\n:::\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nlibrary(data.table)\n\ndata = melt(as.data.table(task), id.vars = task$target_names, measure.vars = task$feature_names)\ndata = data[c(\"V1\", \"V10\", \"V11\", \"V12\", \"V13\", \"V14\"), , on = \"variable\"]\n\nggplot(data, aes(x = value, fill = Class)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~ variable, ncol = 6, scales = \"free\") +\n  scale_fill_viridis_d(end = 0.8) +\n  theme_minimal() +\n  theme(axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![Distribution of the first 5 features in the Sonar dataset.](index_files/figure-html/fig-features-1.png){#fig-features fig-align='center' width=1152}\n:::\n:::\n\n\n# Gradient Boosting Machine\n\nWe start with the [`GBM learner`](https://mlr3extralearners.mlr-org.com/reference/mlr_learners_classif.gbm.html) and set the predict type to `\"prob\"` to obtain class probabilities.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner = lrn(\"classif.gbm\",\n  distribution = \"bernoulli\",\n  predict_type = \"prob\")\n```\n:::\n\n\nNow we define the feature selection problem by using the [`fsi()`](https://mlr3fselect.mlr-org.com/reference/fsi.html) function that constructs an [`FSelectInstanceSingleCrit`](https://mlr3fselect.mlr-org.com/reference/FSelectInstanceSingleCrit.html).\nIn addition to the task and learner, we have to select a [`resampling strategy`](https://mlr3.mlr-org.com/reference/Resampling.html) and [`performance measure`](https://mlr3.mlr-org.com/reference/Measure.html) to determine how the performance of a feature subset is evaluated.\nWe pass the `\"none\"` terminator because the `n_features` parameter of the optimizer determines when the feature selection stops.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninstance = fsi(\n  task = task,\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 6),\n  measures = msr(\"classif.auc\"),\n  terminator = trm(\"none\"))\n```\n:::\n\n\nWe are now ready to start the RFE.\nTo do this, we simply pass the instance to the `$optimize()` method of the optimizer.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer$optimize(instance)\n```\n:::\n\n\nThe optimizer saves the best feature set and the corresponding estimated performance in `instance$result`.\n\n@fig-gbm shows the optimization path of the feature selection.\nWe observe that the performance increases first as the number of features decreases.\nAs soon as informative features are removed, the performance drops.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(viridisLite)\nlibrary(mlr3misc)\n\ndata = as.data.table(instance$archive)\ndata[, n:= map_int(importance, length)]\n\nggplot(data, aes(x = n, y = classif.auc)) +\n  geom_line(\n    color = viridis(1, begin = 0.5),\n    linewidth = 1) +\n  geom_point(\n    fill = viridis(1, begin = 0.5),\n    shape = 21,\n    size = 3,\n    stroke = 0.5,\n    alpha = 0.8) +\n  xlab(\"Number of Features\") +\n  scale_x_reverse() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Performance of the gradient-boosting models depending on the number of features.](index_files/figure-html/fig-gbm-1.png){#fig-gbm fig-align='center' width=672}\n:::\n:::\n\n\nThe importance scores of the feature sets are recorded in the archive.\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code}\nas.data.table(instance$archive)[, list(features, classif.auc, importance)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      features classif.auc                                                importance\n 1: V1,V10,V11,V12,V13,V14,...   0.8929304 58.83333,58.83333,54.50000,54.00000,53.33333,52.50000,...\n 2: V1,V10,V11,V12,V13,V15,...   0.9177811 57.33333,56.00000,54.00000,53.66667,50.50000,50.00000,...\n 3: V1,V10,V11,V12,V13,V15,...   0.9045253 54.83333,54.66667,54.66667,53.00000,51.83333,51.33333,...\n 4: V1,V10,V11,V12,V13,V15,...   0.8927833 56.00000,55.83333,53.00000,52.00000,50.16667,50.00000,...\n 5: V1,V10,V11,V12,V13,V15,...   0.9016274 55.50000,53.50000,51.33333,50.00000,49.00000,48.50000,...\n---                                                                                                 \n56:         V11,V12,V16,V48,V9   0.8311625              4.166667,3.333333,2.833333,2.500000,2.166667\n57:             V11,V12,V16,V9   0.8216772                       3.833333,2.666667,2.000000,1.500000\n58:                V11,V12,V16   0.8065807                                2.833333,1.833333,1.333333\n59:                    V11,V12   0.8023780                                         1.833333,1.166667\n60:                        V11   0.7515904                                                         1\n```\n:::\n:::\n\n\n# Support Vector Machine\n\nNow we will select the optimal feature set for an SVM with a linear kernel.\nThe importance scores are the weights of the model.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner = lrn(\"classif.svm\",\n  type = \"C-classification\",\n  kernel = \"linear\",\n  predict_type = \"prob\")\n```\n:::\n\n\n\nThe [`SVM learner`](https://mlr3learners.mlr-org.com/reference/mlr_learners_classif.svm.html) does not support the calculation of importance scores at first.\nThe reason is that importance scores cannot be determined with all kernels.\nThis can be seen by the missing `\"importance\"` property.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner$properties\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"multiclass\" \"twoclass\"  \n```\n:::\n:::\n\n\nUsing the `\"mlr3fselect.svm_rfe\"` callback however makes it possible to use a linear SVM with the [`RFE`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfe.html) optimizer.\nThe callback adds the `$importance()` method internally to the learner.\nWe load the callback with the [`clbk()`](https://mlr3misc.mlr-org.com/reference/clbk.html) function and pass it as the `\"callback\"` argument to [`fsi()`](https://mlr3fselect.mlr-org.com/reference/fsi.html).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninstance = fsi(\n  task = task,\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 6),\n  measures = msr(\"classif.auc\"),\n  terminator = trm(\"none\"),\n  callback = clbk(\"mlr3fselect.svm_rfe\"))\n```\n:::\n\n\nWe start the feature selection.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer$optimize(instance)\n```\n:::\n\n\n@fig-svm shows the average performance of the SVMs depending on the number of features.\nWe can see that the performance increases significantly with a reduced feature set.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(viridisLite)\nlibrary(mlr3misc)\n\ndata = as.data.table(instance$archive)\ndata[, n:= map_int(importance, length)]\n\nggplot(data, aes(x = n, y = classif.auc)) +\n  geom_line(\n    color = viridis(1, begin = 0.5),\n    linewidth = 1) +\n  geom_point(\n    fill = viridis(1, begin = 0.5),\n    shape = 21,\n    size = 3,\n    stroke = 0.5,\n    alpha = 0.8) +\n  xlab(\"Number of Features\") +\n  scale_x_reverse() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Performance of the support vector machines depending on the number of features.](index_files/figure-html/fig-svm-1.png){#fig-svm fig-align='center' width=672}\n:::\n:::\n\n\nFor datasets with a lot of features, it is more efficient to remove several features per iteration.\nWe show an example where 25% of the features are removed in each iteration.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer = fs(\"rfe\", n_features = 1, feature_fraction = 0.75)\n\ninstance = fsi(\n  task = task,\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 6),\n  measures = msr(\"classif.auc\"),\n  terminator = trm(\"none\"),\n  callback = clbk(\"mlr3fselect.svm_rfe\"))\n\noptimizer$optimize(instance)\n```\n:::\n\n\n@fig-svm-2 shows a similar optimization curve as @fig-svm but with fewer evaluated feature sets.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(viridisLite)\nlibrary(mlr3misc)\n\ndata = as.data.table(instance$archive)\ndata[, n:= map_int(importance, length)]\n\nggplot(data, aes(x = n, y = classif.auc)) +\n  geom_line(\n    color = viridis(1, begin = 0.5),\n    linewidth = 1) +\n  geom_point(\n    fill = viridis(1, begin = 0.5),\n    shape = 21,\n    size = 3,\n    stroke = 0.5,\n    alpha = 0.8) +\n  xlab(\"Number of Features\") +\n  scale_x_reverse() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Optimization path of the feature selection.](index_files/figure-html/fig-svm-2-1.png){#fig-svm-2 fig-align='center' width=672}\n:::\n:::\n\n\n# Recursive Feature Elimination with Cross Validation\n\nRFE-CV estimates the optimal number of features before selecting a feature set.\nFor this, an RFE is run in each resampling iteration and the number of features with the best mean performance is selected (see @fig-flowchart).\nThen one more RFE is carried out on the complete dataset with the optimal number of features as the final feature set size.\n\n\n```{mermaid}\n%%| label: fig-flowchart\n%%| fig-cap: Example of an RFE-CV. The optimal number of features is estimated with a 3-fold cross-validation. One RFE is executed with each train-test split (RFE 1 to RFE 3). The number of features with the best mean performance (green rectangles) is used as the size of the final feature set. A final RFE is performed on all observations. The algorithm stops when the optimal feature set size is reached (purple rectangle) and the optimized feature set is returned.\n\n%%{ init: { 'flowchart': { 'curve': 'bump' } } }%%\nflowchart TB\n    cross-validation[3-Fold Cross-Validation]\n    cross-validation-->rfe-1\n    cross-validation-->rfe-2\n    cross-validation-->rfe-3\n    subgraph rfe-1[RFE 1]\n    direction TB\n    f14[4 Features]\n    f13[3 Features]\n    f12[2 Features]\n    f11[1 Features]\n    f14-->f13-->f12-->f11\n    style f13 fill:#ccea84\n    end\n    subgraph rfe-2[RFE 2]\n    direction TB\n    f24[4 Features]\n    f23[3 Features]\n    f22[2 Features]\n    f21[1 Features]\n    f24-->f23-->f22-->f21\n    style f23 fill:#ccea84\n    end\n    subgraph rfe-3[RFE 3]\n    direction TB\n    f34[4 Features]\n    f33[3 Features]\n    f32[2 Features]\n    f31[1 Features]\n    f34-->f33-->f32-->f31\n    style f33 fill:#ccea84\n    end\n    all_obs[All Observations]\n    rfe-1-->all_obs\n    rfe-2-->all_obs\n    rfe-3-->all_obs\n    all_obs --> rfe\n    subgraph rfe[RFE]\n    direction TB\n    f54[4 Features]\n    f53[3 Features]\n    f54-->f53\n    style f53 fill:#8e6698\n    end\n```\n\n\nWe retrieve the [`RFE-CV`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfecv.html) optimizer.\nRFE-CV has almost the same control parameters as the RFE optimizer.\nThe only difference is that no aggregation is needed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer = fs(\"rfecv\",\n  n_features = 1,\n  feature_number = 1)\n```\n:::\n\n\nThe chosen resampling strategy is used to estimate the optimal number of features.\nThe 6-fold cross-validation results in 6 RFE runs.\nYou can choose any other resampling strategy with multiple iterations.\nLet's start the feature selection.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner = lrn(\"classif.svm\",\n  type = \"C-classification\",\n  kernel = \"linear\",\n  predict_type = \"prob\")\n\ninstance = fsi(\n  task = task,\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 6),\n  measures = msr(\"classif.auc\"),\n  terminator = trm(\"none\"),\n  callback = clbk(\"mlr3fselect.svm_rfe\"))\n\noptimizer$optimize(instance)\n```\n:::\n\n\n::: {.callout-warning}\nThe performance of the optimal feature set is calculated on the complete data set and should not be reported as the performance of the final model.\nEstimate the performance of the final model with [nested resampling](https://mlr3book.mlr-org.com/optimization.html#sec-nested-resampling).\n:::\n\nWe visualize the selection of the optimal number of features.\nEach point is the mean performance of the number of features.\nWe achieved the best performance with 19 features.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nlibrary(viridisLite)\nlibrary(mlr3misc)\n\ndata = as.data.table(instance$archive)[!is.na(iteration), ]\naggr = data[, list(\"y\" = mean(unlist(.SD))), by = \"batch_nr\", .SDcols = \"classif.auc\"]\naggr[, batch_nr := 61 - batch_nr]\n\ndata[, n:= map_int(importance, length)]\n\nggplot(aggr, aes(x = batch_nr, y = y)) +\n  geom_line(\n    color = viridis(1, begin = 0.5),\n    linewidth = 1) +\n  geom_point(\n    fill = viridis(1, begin = 0.5),\n    shape = 21,\n    size = 3,\n    stroke = 0.5,\n    alpha = 0.8) +\n  geom_vline(\n    xintercept = aggr[y == max(y)]$batch_nr,\n    colour = viridis(1, begin = 0.33),\n    linetype = 3\n  ) +\n  xlab(\"Number of Features\") +\n  ylab(\"Mean AUC\") +\n  scale_x_reverse() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Estimation of the optimal number of features. The best mean performance is achieved with 19 features (blue line).](index_files/figure-html/fig-rfecv-1.png){#fig-rfecv fig-align='center' width=672}\n:::\n:::\n\n\nThe archive contains the extra column `\"iteration\"` that indicates in which resampling iteration the feature set was evaluated.\nThe feature subsets of the final RFE run have no value in the `\"iteration\"` column because they were evaluated on the complete data set.\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code}\nas.data.table(instance$archive)[, list(features, classif.auc, iteration, importance)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       features classif.auc iteration                                                      importance\n  1: V1,V10,V11,V12,V13,V14,...   0.8782895         1       2.864018,1.532774,1.408485,1.399930,1.326165,1.167745,...\n  2: V1,V10,V11,V12,V13,V14,...   0.7026144         2       2.056442,1.706077,1.258703,1.191762,1.190752,1.178514,...\n  3: V1,V10,V11,V12,V13,V14,...   0.8790850         3       1.950412,1.887710,1.820891,1.616219,1.231928,1.138675,...\n  4: V1,V10,V11,V12,V13,V14,...   0.8125000         4 2.6958580,1.5623759,1.4990138,1.3902109,0.9385757,0.9232132,...\n  5: V1,V10,V11,V12,V13,V14,...   0.8807018         5       2.487483,1.470778,1.356517,1.033764,0.635383,0.575074,...\n ---                                                                                                                 \n398:  V1,V11,V12,V16,V23,V3,...   0.9605275        NA 2.0089739,1.1047492,1.0011253,0.6602411,0.6015470,0.5431803,...\n399:  V1,V12,V16,V23,V3,V30,...   0.9595988        NA 1.8337471,1.1937962,0.9853467,0.7751384,0.7296726,0.6222569,...\n400:  V1,V12,V16,V23,V3,V30,...   0.9589486        NA 1.8824952,1.2468164,1.0106654,0.8090618,0.6983925,0.6568389,...\n401:  V1,V12,V16,V23,V3,V30,...   0.9559766        NA 2.3872902,0.9094028,0.8809098,0.8277941,0.7841591,0.7792772,...\n402:  V1,V12,V16,V23,V3,V30,...   0.9521687        NA 1.9485133,1.1482257,1.1098823,0.9591012,0.8234140,0.8118616,...\n```\n:::\n:::\n\n\n# Final Model\n\nThe learner we use to make predictions on new data is called the final model.\nThe final model is trained with the optimal feature set on the full data set.\nThe optimal set consists of 19 features and is stored in `instance$result_feature_set`.\nWe subset the task to the optimal feature set and train the learner.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask$select(instance$result_feature_set)\nlearner$train(task)\n```\n:::\n\n\nThe trained model can now be used to predict new, external data.\n\n# Conclusion\n\nThe RFE algorithm is a valuable feature selection method, especially for high-dimensional datasets with only a few observations.\nThe numerous settings of the algorithm in mlr3 make it possible to apply it to many datasets and learners.\nIf you want to know more about feature selection in general, we recommend having a look at our [book](https://mlr3book.mlr-org.com/feature-selection.html).\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}