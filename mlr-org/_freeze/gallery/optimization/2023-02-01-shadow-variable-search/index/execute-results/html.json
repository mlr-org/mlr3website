{
  "hash": "6c5b87f5b59bf6a83af812eda48d82b8",
  "result": {
    "markdown": "---\ntitle: \"Shadow Variable Search on the Pima Indian Diabetes Data Set\"\ndescription: |\n  Run a feature selection with permutated features.\ncategories:\n  - feature selection\n  - classification\nauthor:\n  - name: Marc Becker\n    url: https://github.com/be-marc\n  - name: Sebastian Fischer\n    url: https://github.com/sebffischer\ndate: 2023-02-01\nbibliography: ../../bibliography.bib\nknitr:\n  opts_chunk:\n    R.options:\n      datatable.print.nrows: 6\n---\n\n\n\n\n\n\n# Scope\n\nFeature selection is the process of finding an optimal set of features to improve the performance, interpretability and robustness of machine learning algorithms.\nIn this article, we introduce the *Shadow Variable Search* algorithm which is a [wrapper method](https://mlr3book.mlr-org.com/feature-selection.html#fs-wrapper) for feature selection.\nWrapper methods iteratively add features to the model that optimize a performance measure.\nAs an example, we will search for the optimal set of features for a [`support vector machine`](https://mlr3learners.mlr-org.com/reference/mlr_learners_classif.svm.html) on the [`Pima Indian Diabetes`](https://mlr3.mlr-org.com/reference/mlr_tasks_pima.html) data set.\nWe assume that you are already familiar with the basic building blocks of the [mlr3 ecosystem](https://mlr-org.com/ecosystem.html).\nIf you are new to feature selection, we recommend reading the [feature selection chapter](https://mlr3book.mlr-org.com/feature-selection.html) of the mlr3book first.\nSome knowledge about [mlr3pipelines](https://mlr3pipelines.mlr-org.com) is beneficial but not necessary to understand the example.\n\n# Shadow Variable Search\n\nAdding shadow variables to a data set is a well-known method in machine learning [@wu_controlling_2007; @thomas_probing_2017].\nThe idea is to add permutated copies of the original features to the data set.\nThese permutated copies are called shadow variables or pseudovariables and the permutation breaks any relationship with the target variable, making them useless for prediction.\nThe subsequent search is similar to the sequential forward selection algorithm, where one new feature is added in each iteration of the algorithm.\nThis new feature is selected as the one that improves the performance of the model the most.\nThis selection is computationally expensive, as one model for each of the not yet included features has to be trained.\nThe difference between shadow variable search and sequential forward selection is that the former uses the selection of a shadow variable as the termination criterion.\nSelecting a shadow variable means that the best improvement is achieved by adding a feature that is unrelated to the target variable.\nConsequently, the variables not yet selected are most likely also correlated to the target variable only by chance.\nTherefore, only the previously selected features have a true influence on the target variable.\n\n[mlr3fselect](https://mlr3fselect.mlr-org.com) is the feature selection package of the [mlr3 ecosystem](https://mlr-org.com/ecosystem.html).\nIt implements the [`shadow variable search`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_shadow_variable_search.html) algorithm.\nWe load all packages of the ecosystem with the [`mlr3verse`](https://mlr3verse.mlr-org.com/reference/mlr3verse-package.html) package.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlr3verse)\n```\n:::\n\n\nWe retrieve the [`shadow variable search`](https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_shadow_variable_search.html) optimizer with the [`fs()`](https://mlr3fselect.mlr-org.com/reference/fs.html) function.\nThe algorithm has no control parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer = fs(\"shadow_variable_search\")\n```\n:::\n\n\n# Task and Learner\n\nThe objective of the [`Pima Indian Diabetes`](https://mlr3.mlr-org.com/reference/mlr_tasks_pima.html) data set is to predict whether a person has diabetes or not.\nThe data set includes 768 patients with 8 measurements (see @fig-features).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask = tsk(\"pima\")\n```\n:::\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nlibrary(data.table)\n\ndata = melt(as.data.table(task), id.vars = task$target_names, measure.vars = task$feature_names)\n\nggplot(data, aes(x = value, fill = diabetes)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~ variable, ncol = 8, scales = \"free\") +\n  scale_fill_viridis_d(end = 0.8) +\n  theme_minimal() +\n  theme(axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![Distribution of the features in the Pima Indian Diabetes data set.](index_files/figure-html/fig-features-1.png){#fig-features fig-align='center' width=1344}\n:::\n:::\n\n\nThe data set contains missing values.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask$missings()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndiabetes      age  glucose  insulin     mass pedigree pregnant pressure  triceps \n       0        0        5      374       11        0        0       35      227 \n```\n:::\n:::\n\n\nSupport vector machines cannot handle missing values.\nWe impute the missing values with the [`histogram imputation`](https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_imputehist.html) method.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner = po(\"imputehist\") %>>% lrn(\"classif.svm\", predict_type = \"prob\")\n```\n:::\n\n\n# Feature Selection\n\nNow we define the feature selection problem by using the [`fsi()`](https://mlr3fselect.mlr-org.com/reference/fsi.html) function that constructs an [`FSelectInstanceSingleCrit`](https://mlr3fselect.mlr-org.com/reference/FSelectInstanceSingleCrit.html).\nIn addition to the task and learner, we have to select a [`resampling strategy`](https://mlr3.mlr-org.com/reference/Resampling.html) and [`performance measure`](https://mlr3.mlr-org.com/reference/Measure.html) to determine how the performance of a feature subset is evaluated.\nWe pass the `\"none\"` terminator because the shadow variable search algorithm terminates by itself.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninstance = fsi(\n  task = task,\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 3),\n  measures = msr(\"classif.auc\"),\n  terminator = trm(\"none\")\n)\n```\n:::\n\n\nWe are now ready to start the shadow variable search.\nTo do this, we simply pass the instance to the `$optimize()` method of the optimizer.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptimizer$optimize(instance)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    age glucose insulin mass pedigree pregnant pressure triceps                  features classif.auc\n1: TRUE    TRUE   FALSE TRUE     TRUE    FALSE    FALSE   FALSE age,glucose,mass,pedigree    0.835165\n```\n:::\n:::\n\n\nThe optimizer returns the best feature set and the corresponding estimated performance.\n\n@fig-optimization-path shows the optimization path of the feature selection.\nThe feature glucose was selected first and in the following iterations age, mass and pedigree.\nThen a shadow variable was selected and the feature selection was terminated.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(mlr3misc)\nlibrary(viridisLite)\n\ndata = as.data.table(instance$archive)[order(-classif.auc), head(.SD, 1), by = batch_nr][order(batch_nr)]\ndata[, features := map_chr(features, str_collapse)]\ndata[, batch_nr := as.character(batch_nr)]\n\nggplot(data, aes(x = batch_nr, y = classif.auc)) +\n  geom_bar(\n    stat = \"identity\",\n    width = 0.5,\n    fill = viridis(1, begin = 0.5),\n    alpha = 0.8) +\n  geom_text(\n    data = data,\n    mapping = aes(x = batch_nr, y = 0, label = features),\n    hjust = 0,\n    nudge_y = 0.05,\n    color = \"white\",\n    size = 5\n    ) +\n  coord_flip() +\n  xlab(\"Iteration\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Optimization path of the shadow variable search.](index_files/figure-html/fig-optimization-path-1.png){#fig-optimization-path fig-align='center' width=672}\n:::\n:::\n\n\nThe archive contains all evaluated feature sets.\nWe can see that each feature has a corresponding shadow variable.\nWe only show the variables age, glucose and insulin and their shadow variables here.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas.data.table(instance$archive)[, .(age, glucose, insulin, permuted__age, permuted__glucose, permuted__insulin, classif.auc)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      age glucose insulin permuted__age permuted__glucose permuted__insulin classif.auc\n 1:  TRUE   FALSE   FALSE         FALSE             FALSE             FALSE   0.6437052\n 2: FALSE    TRUE   FALSE         FALSE             FALSE             FALSE   0.7598155\n 3: FALSE   FALSE    TRUE         FALSE             FALSE             FALSE   0.4900280\n 4: FALSE   FALSE   FALSE         FALSE             FALSE             FALSE   0.6424026\n 5: FALSE   FALSE   FALSE         FALSE             FALSE             FALSE   0.5690107\n---                                                                                    \n54:  TRUE    TRUE   FALSE         FALSE             FALSE             FALSE   0.8266713\n55:  TRUE    TRUE   FALSE         FALSE             FALSE             FALSE   0.8063568\n56:  TRUE    TRUE   FALSE         FALSE             FALSE             FALSE   0.8244232\n57:  TRUE    TRUE   FALSE         FALSE             FALSE             FALSE   0.8234605\n58:  TRUE    TRUE   FALSE         FALSE             FALSE             FALSE   0.8164784\n```\n:::\n:::\n\n\n# Final Model\n\nThe learner we use to make predictions on new data is called the final model.\nThe final model is trained with the optimal feature set on the full data set.\nWe subset the task to the optimal feature set and train the learner.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntask$select(instance$result_feature_set)\nlearner$train(task)\n```\n:::\n\n\nThe trained model can now be used to predict new, external data.\n\n# Conclusion\n\nThe shadow variable search is a fast feature selection method that is easy to use.\nMore information on the theoretical background can be found in @wu_controlling_2007 and @thomas_probing_2017.\nIf you want to know more about feature selection in general, we recommend having a look at our [book](https://mlr3book.mlr-org.com/feature-selection.html).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}