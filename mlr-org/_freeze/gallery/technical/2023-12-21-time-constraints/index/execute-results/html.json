{
  "hash": "74c0b727cff5bbd75eedc9d66e47fec2",
  "result": {
    "markdown": "---\ntitle: \"Setting time constraints in mlr3 ecosystem\"\ndescription: |\n  Set time limits for learners, tuning and nested resampling.\nauthor:\n  - name: Marc Becker\n    orcid: 0000-0002-8115-0400\n    url: https://github.com/be-marc\ndate: 2023-12-21\nbibliography: ../../bibliography.bib\nimage: cover.jpg\n---\n\n\n# Scope\n\nThis article gives a quick overview on how to set time constraints in the mlr3 ecosystem.\nTime constraints can be set for individual learners, tuning processes and nested resampling.\nSetting a time limit is important for successful tuning and on shared computing resources.\n\n## Learner\n\nWe load the tuning package and use an support vector machine.\nThe training of an svm can be time consuming.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mlr3verse)\n\nlearner = lrn(\"classif.svm\")\n```\n:::\n\n\nSetting timeouts on the `$train()` and `$predict()` functions guards against learners that run for an indefinite amount of time.\nWe set a time limit of 10 seconds for the training of the svm.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner$timeout = c(train = 10, predict = Inf)\n```\n:::\n\n\nWe need to encapsulate the training and prediction process in a separate R process to be able to kill it.\nUsing `callr` encapsulation works most reliable, since the `evaluate` package is sometimes not able to terminate external compiled code.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner$encapsulate = c(train = \"callr\", predict = \"callr\")\n```\n:::\n\n\nUsing `callr` comes with an increased runtime for starting the R process.\n\n## Tuning\n\nJobs on high-performance clusters are often limited to a certain amount of time.\nIf the time limit is exceeded, the job is killed and the results are lost.\nSo we have to make sure that the tuning process does not exceed the time limit.\n\nThe `trm(\"runtime\")` terminates the tuning process after a certain amount of time.\nWe must take into account that the terminator can only check the time between batches.\nWe must therefore set the time lower than the runtime of the job.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nterminator = trm(\"run_time\", secs = 60)\n\ninstance = ti(\n  task = tsk(\"sonar\"),\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 3),\n  measures = msr(\"classif.ce\"),\n  terminator = terminator\n)\n```\n:::\n\n\n## Nested Resampling\n\nWhen using nested resampling, we can also set a timeout in the outer resampling iterations.\nIt works the same way as for the learner.\n\nThe nested resampling can take a maximum time of 10 minutes (120 seconds * 5 folds).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlearner = lrn(\"classif.svm\")\nlearner$encapsulate = c(train = \"callr\", predict = \"callr\")\nlearner$timeout = c(train = 10, predict = Inf)\n\nterminator = trm(\"runtime\", secs = 60)\n\nat = auto_tuner(\n  learner = learner,\n  resampling = rsmp(\"cv\", folds = 3),\n  measures = msr(\"classif.ce\"),\n  terminator = terminator\n)\n\nat$encapsulate = c(train = \"callr\", predict = \"callr\")\nat$timeout = c(train = 120, predict = Inf)\n\nrr = resample(task, at, rsmp(\"cv\", folds = 5))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}